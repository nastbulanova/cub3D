# Подробное объяснение кода

## 1. Общая логика

### `int main`

- **Шаги**  
  1. Проверяет, что передан ровно один аргумент.  
  2. Парсит файл `.cub` в структуру `t_map`.  
  3. Инициализирует всё состояние для рендеринга и игры на основе карты.  
  4. Выполняет первый проход рендеринга.  
  5. Отображает полученное изображение в окне.  
  6. Устанавливает обработчики нажатий клавиш и закрытия окна.  
  7. Входит в цикл событий (повторный рендер при каждом событии клавиатуры).

---

## 2. Рендеринг

### Файл: `render.c`

#### `void put_pixel(t_img *img, int x, int y, int color)`
- **Назначение:** Нарисовать один пиксель заданного цвета в буфере изображения MLX.  
- **Параметры:**  
  - `img` – указатель на оффскрин-изображение (`t_img`)  
  - `x, y` – координаты на экране (0 ≤ x < ШИРИНА, 0 ≤ y < ВЫСОТА)  
  - `color` – целое `0xRRGGBB`  
- **Что делает:**  
  Вычисляет адрес в `img->addr` (с учётом `bits_per_pixel` и `line_length`) и записывает 4-байтовое значение цвета.

#### `void render_scene(t_cub_data *data, t_scene *scene)`
- **Назначение:** Запустить полный проход рэйкастинга для отрисовки кадра.  
- **Параметры:**  
  - `data` – структура верхнего уровня (содержит игрока, масштаб FOV, текстуры)  
  - `scene` – содержит контекст рисования и ссылку на игрока  
- **Что делает:**  
  1. Устанавливает `scene->player` из `data->player`.  
  2. Вызывает `draw_ceil_floor(scene)` для заполнения потолка и пола.  
  3. Вычисляет плоскость камеры из направления игрока и масштаба FOV.  
  4. В цикле по `x` от 0 до `WINDOW_WIDTH - 1` вызывает `render_column(data, scene, x)`.

---

### Файл: `render_init.c`

#### `t_texture *add_wall_pixels(t_draw *draw, char *file)`
- **Назначение:** Загрузить одну текстуру стены из файла в изображение MLX и вернуть `t_texture`.  
- **Параметры:**  
  - `draw` – содержит соединение MLX  
  - `file` – путь до `.xpm` текстуры  
- **Что делает:**  
  Вызывает `mlx_xpm_file_to_image`, получает ширину/высоту и `addr` через `mlx_get_data_addr`, оборачивает в `t_texture`, возвращает `NULL` при ошибке.

#### `t_scene *render_init(t_cub_data *data, t_map *map)`
- **Назначение:** Выделить и заполнить `t_scene` для рендеринга.  
- **Параметры:**  
  - `data` – состояние игры верхнего уровня  
  - `map` – распарсенная карта `.cub`  
- **Что делает:**  
  1. Вызывает `init_scene_basics(data, map)`.  
  2. Вызывает `setup_draw_and_textures(scene, map)` (окно, буфер, текстуры).  
  3. Возвращает заполненный `t_scene` или `NULL` при ошибке.

---

### Файл: `render_init_utils_1.c`

#### `float get_fov_scale(void)`
- **Назначение:** Вычислить длину плоскости камеры на основе константы FOV.  
- **Что делает:**  
  Конвертирует `FOV` в радианы и возвращает `tan(fov_rad / 2)`.

#### `int rgb_to_color(t_rgb *color)`
- **Назначение:** Упаковать три значения 0–255 в одно целое `0xRRGGBB`.  
- **Что делает:**  
  Сдвигает `r` на 16 бит, `g` на 8 бит, объединяет с `b`.

---

### Файл: `render_init_utils_2.c`

#### `void set_dimensions(t_map *map, int *width, int *height)`
- **Назначение:** Определить итоговое разрешение рендеринга из настроек карты или по умолчанию.  
- **Параметры:**  
  - `map` – может содержать переопределённые `res_w`/`res_h`  
  - `width, height` – выходные указатели  

#### `int setup_draw_and_textures(t_scene *scene, t_map *map)`
- **Назначение:** Создать окно/буфер и загрузить текстуры.  
- **Что делает:**  
  1. Вызывает `draw_init(map)`.  
  2. Вызывает `load_textures(scene->draw, map)`.  
  3. Возвращает `1` при успехе, `0` при ошибке.

---

### Файл: `render_ray_utils.c`

#### `void calculate_ray(t_scene *scene, int x, t_ray *ray)`
- **Назначение:** Инициализировать `t_ray` для столбца экрана `x`.  
- **Что делает:**  
  Вычисляет направление луча из `player.dir` + `camera_plane`, устанавливает `map_x/map_y`, вычисляет `delta_dist_*`, выбирает `step_*` и `side_dist_*`.

#### `double calculate_wall_distance(t_scene *scene, t_ray *ray, int map_x, int map_y)`
- **Назначение:** Вычислить перпендикулярное расстояние до стены после DDA.  
- **Что делает:**  
  Применяет формулу в зависимости от `ray->side`, возвращает `perp_dist`.

---

### Файл: `render_tex_utils.c`

#### `unsigned int get_tex_pixel(t_texture *tex, int x, int y)`
- **Назначение:** Считать цвет пикселя из текстуры.  
- **Параметры:**  
  - `tex` – текстура с `img.addr`, `line_length` и т.д.  
  - `x, y` – координаты в текстуре  
- **Что делает:**  
  Вычисляет смещение `(y*line_length + x*(bpp/8))`, возвращает 4-байтовое значение цвета.

#### `int calculate_tex_x(t_scene *scene, t_ray *ray, double perp_dist, t_texture *tex)`
- **Назначение:** Определить, какой вертикальный срез текстуры использовать.  
- **Что делает:**  
  1. Вычисляет точное место попадания `wall_x`.  
  2. Берёт дробную часть `wall_x * tex->width`.  
  3. При необходимости инвертирует `tex_x`, возвращает `tex_x`.

---

## 3. Парсинг

### Файл: `finalize_grid.c`

#### `static size_t find_maxlen(char **raw, int rows)`
- **Назначение:** Найти длину самой длинной строки в `raw`.  
- **Параметры:**  
  - `raw` – массив из `rows` строк  
  - `rows` – число строк  
- **Что делает:** Возвращает максимальное `strlen(raw[i])`.

#### `static char **alloc_grid(int rows, int cols)`
- **Назначение:** Выделить прямоугольный массив `rows × cols`.  
- **Параметры:**  
  - `rows`, `cols` – размеры  
- **Что делает:** Выделяет `rows` указателей, каждый из `cols+1` байта.

#### `static void fill_grid(char **grid, char **raw, int rows, int cols)`
- **Назначение:** Скопировать `raw` в `grid`, дополняя пробелами.  
- **Параметры:**  
  - `grid`, `raw`, `rows`, `cols`  
- **Что делает:** Копирует каждую строку, заполняя остаток пробелами, завершая нулём.

#### `static void free_raw(char **raw, int rows)`
- **Назначение:** Освободить нерегулярный массив `raw`.  
- **Параметры:**  
  - `raw`, `rows`  
- **Что делает:** Освобождает `raw[i]`, затем `raw`.

#### `char **finalize_grid(char **raw, int rows, int *out_cols)`
- **Назначение:** Преобразовать `raw` в прямоугольный массив.  
- **Параметры:**  
  - `raw`, `rows`, `out_cols`  
- **Что делает:**  
  1. Считает `*out_cols` через `find_maxlen`.  
  2. Выделяет через `alloc_grid`.  
  3. Заполняет через `fill_grid`.  
  4. Освобождает `raw` с помощью `free_raw`.  
  5. Возвращает новую `grid`.

---

### Файл: `parsing_utils_1.c`

#### `void parse_color_line(char **target, char *line)`
- **Назначение:** Обработать директиву цвета пола/потолка.  
- **Параметры:**  
  - `target` – адрес `map->floor` или `map->ceil`  
  - `line` – строка вида `"F …"` или `"C …"`  
- **Что делает:** Дублирует `line+1` в `*target`.

#### `void add_map_line(t_map *map, char *line, char ***grid, int *rows)`
- **Назначение:** Добавить одну строку карты в сырой массив.  
- **Параметры:**  
  - `map`, `line`, `grid`, `rows`  
- **Что делает:** Использует `realloc_list` для расширения `grid`, дублирует `line`, увеличивает `*rows`.

#### `void process_line(t_map *map, char *line, char ***grid, int *rows)`
- **Назначение:** Перенаправить строку к соответствующему парсеру.  
- **Параметры:**  
  - `map`, `line`, `grid`, `rows`  
- **Что делает:** Вызывает `parse_resolution_line`, `parse_texture_line`, `parse_color_line` или `add_map_line`, иначе — ошибка.

#### `void read_map_lines(int fd, t_map *map)`
- **Назначение:** Считать и обработать все строки из файла карты.  
- **Параметры:**  
  - `fd`, `map`  
- **Что делает:** В цикле `get_next_line` очищает строку, пропускает пустые, вызывает `process_line`, сохраняет `map->map` и `map->rows`.

---

### Файл: `parsing_utils_2.c`

#### `t_map *init_map_struct(void)`
- **Назначение:** Выделить и обнулить новую `t_map`.  
- **Возвращает:** Указатель или выходит при ошибке.

#### `bool is_texture_line(char *line)`
- **Назначение:** Распознать директивы `NO `, `SO `, `WE `, `EA `.  
- **Возвращает:** `true`, если строка начинается с одной из них.

#### `bool is_map_line(char *line)`
- **Назначение:** Определить начало блока карты (`'1'`).  
- **Возвращает:** `true`, если первый не-пробельный символ — `'1'`.

#### `bool is_blank_line(char *line)`
- **Назначение:** Определить пустую строку.  
- **Возвращает:** `true`, если `line` пустая или состоит из пробелов/табов.

#### `char *strip_line(const char *line)`
- **Назначение:** Скопировать строку без завершающего `\n`.  
- **Возвращает:** Дублированную строку или `NULL`.

---

### Файл: `parsing_utils_3.c`

#### `void parse_resolution_line(t_map *map, char *line)`
- **Назначение:** Разобрать директиву `R ширина высота`.  
- **Параметры:** `map`, `line`  
- **Что делает:** Разбивает `line+1`, конвертирует в `map->res_w`/`res_h`, проверяет корректность.

#### `void parse_texture_line(t_map *map, char *line)`
- **Назначение:** Разобрать пути текстур `NO `, `SO `, `WE `, `EA `.  
- **Параметры:** `map`, `line`  
- **Что делает:** Дублирует `line+3` в соответствующее поле `map->file_*`.

---

### Файл: `validate_map.c`

#### `static int count_player_starts_in_row(char *row, int max_cols)`
- **Назначение:** Подсчитать маркеры старта `N`, `S`, `E`, `W` в строке.  
- **Возвращает:** Количество маркеров.

#### `static int count_player_starts(t_map *map)`
- **Назначение:** Подсчитать все маркеры старта в карте.  
- **Возвращает:** Общее число.

#### `static void check_cell_enclosed(t_map *map, int y, int x)`
- **Назначение:** Проверить, что проходимая клетка окружена стенами.  
- **Что делает:** Ошибка, если клетка на границе или рядом с пробелом.

#### `static void check_map_enclosure(t_map *map)`
- **Назначение:** Убедиться, что все проходимые/стартовые клетки окружены стенами.

#### `void validate_map(t_map *map)`
- **Назначение:** Проверка целостности карты перед использованием.  
- **Что делает:** Проверяет ненулевые указатели, ровно один старт, вызывает `check_map_enclosure`.

